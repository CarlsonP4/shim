<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>SciDB Simple Telemetry Service</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
 <link href="css/bootstrap.css" rel="stylesheet">
 <style type="text/css">
   body {
     padding-top: 60px;
     padding-bottom: 40px;
   }
   .allgreen
   {
     color: #007700;
   }
   .instances
   {
     -moz-column-count:3; /* Firefox */
     -webkit-column-count:3; /* Safari and Chrome */
     column-count:3;
     -moz-column-gap:40px; /* Firefox */
     -webkit-column-gap:40px; /* Safari and Chrome */
     column-gap:40px;
   }

    table.api-param-values {
        align: center;
        width: 100%;
    }

    table.api-param-values th, table.api-param-values td {
        text-align: left;
        vertical-align: top;
        padding: 6px 6px 6px 11px;
    }

    table.api-param-values tr {
        width: 20px;
    }

    table.api-param-values tr:nth-child(2) td {
        padding-top: 11px;
    }
    table.api-param-values tr:last-child td {
        padding-bottom: 12px;
    }

    table.center-first-col tr td:first-child, table.center-first-col tr th:first-child {
        text-align: center;
        width: 70px;
    }

    table.api-param-values th {
        background-color: #fafafa;
        border-bottom: 1px solid #ddd;
    }

 </style>
 <link href="css/bootstrap-responsive.css" rel="stylesheet">
 <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
 <!--[if lt IE 9]>
    <script src="../assets/js/html5shiv.js"></script>
 <![endif]-->
 <link rel="apple-touch-icon-precomposed" href="img/favicon.png">
 <link rel="shortcut icon" href="img/favicon.ico">
</head>

<body>

  <div class="navbar navbar-inverse navbar-fixed-top">
    <div class="navbar-inner">
      <div class="container">
        <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </a>
        <a class="brand" href="index.html">SciDB</a>
        <div class="nav-collapse collapse">
          <ul class="nav">
            <li><a href="index.html">Dashboard</a></li>
            <li><a href="query.html">Interactive Query</a></li>
            <li><a href="help.html">Help</a></li>
            <li><a href="api.html">HTTP API</a></li>
            <li class="active"><a href="telemetry.html">Telemetry API</a></li>
          </ul>
          <div class="pull-right">
            <ul class="nav">
            <li><a href="http://paradigm4.com">http://paradigm4.com</a>
            <ul>
          </div>
        </div><!--/.nav-collapse -->
      </div>
    </div>
  </div>

  <div class="container">

<h2>Shim Telemetry API</h2>
<p>
In addition to the simple HTTP SciDB query API  outlined in <a
href="./api.html">api.html</a>, the shim defines a simple service API
for collecting and distributing SciDB cluster telemetry data and statistics.
The telemetry API goals are simplicity, independence from the collected
statistics, and efficiency.
</p>
<p>
Shim's telemetry API consists of only two services
<ol>
<li> Collecting telemetry data from nodes in a SciDB cluster
<li> Reporting a timeseries of collected data to interested clients
</ol>
Shim is not aware of the structure of the collected data (although it
imposes some limits on it). Shim only
serves as a central aggregation and distribution point.
</p>
<p>
The following sections assume that shim is installed and configured; see
the <a href="./api.html">api.html</a> documentation for setting up shim.
The telemetry API can be authenticated and TLS-encrypted or not. The examples
below show unencrypted connections for simplicity.
</p>


<h2>Collecting telemetry data</h2>

<p>
The /measurement service defines a passive telemetry data collection function.
Programs contact shim on the /measurement service to announce new data. The
service takes a single query parameter, data, that the program
may use to supply an aribtrary string containing its measurements.
The formatting of the data string is up to the program, but is usually
comma separated text values. Note that the telemetry data string is limited
to at most 128 characters, larger data strings return an error.
</p><p>
Shim maintains a circular buffer for storing measurements. When a new
measurement is reported, shim inserts it into the buffer along with a 
pre-pended timestamp in seconds (Unix time) followed by a comma character.
Each measurement is limited to 128 bytes including the
timestamp and comma character, longer measurements are rejected or truncated.
</p>
<p>
It's up to the SciDB nodes to start programs that periodically post telemetry
data to shim using this service--shim does not actively collect any data.
See the example below for a simple shell script that repots free memory
and load average.
</p>

<div class="api">
<table class="api-param-values">
<tr>
<td colspan="2">
<h3>/measurement</h3>
<tr><td>DESCRIPTION
<td>Report measurement data to the telemetry API
<tr><td>METHOD<td>GET
<tr><td>PARAMETERS
<td>
<b>data</b> Free-form data string, limited to 128 bytes.
<tr><td>RESPONSE
<td>Success: HTTP 200
<br/>
Failure (out of resources/server unavailable): HTTP 503
<br/>
Invalid request (usually missing data parameter): HTTP 400
<br/>
<tr><td>EXAMPLE
<td>
http://localhost:8080/measurement?data=myhostname,50.6,12.1
<br/><br/>
<pre>
HTTP/1.0 200 OK
</pre>
<td>
</table>
</div>

<p>
Here is an example shell script that periodically sends free memory
and load average statistics to shim using wget.
<pre>
#!/bin/bash
# Collect basic node statistics and report them to shim
# Usage: stats.sh SHIM_HOST:SHIM_PORT

while true;
do
  M=$(cat /proc/meminfo)
  total=$(echo "${M}" | grep "^MemTotal" | cut -d ':' -f 2 | sed -e "s/^ *//" | sed -e "s/ .*//")
  free=$(echo "${M}" | grep "^MemFree" | cut -d ':' -f 2 | sed -e "s/^ *//" | sed -e "s/ .*//")
  cached=$(echo "${M}" | grep "^Cached" | cut -d ':' -f 2 | sed -e "s/^ *//" | sed -e "s/ .*//")
  buffers=$(echo "${M}" | grep "^Buffers" | cut -d ':' -f 2 | sed -e "s/^ *//" | sed -e "s/ .*//")
  shmem=$(echo "${M}" | grep "^Shmem" | cut -d ':' -f 2 | sed -e "s/^ *//" | sed -e "s/ .*//")

  n=$(hostname)   # Host name
# Percent free memory
  mem=$(echo "scale=2;100*($free + $cached + $buffers - $shmem)/$total" | bc)
# one minute load average
  load=$(cat /proc/loadavg | cut -d ' ' -f 1)
  msg="${n},${mem},${load}"
  wget -O - -q "http://${1}/measurement?data=${msg}" >/dev/null 2>&1
  sleep 30
done
</pre>
</p>


<br/>
<h2>Reporting telemetry data</h2>
<p>
Shim reports collected telemetry data on a websockets interface. New data
are streamed to the client websocket as they become available, simplifying
dynamic display of the data.
</p>
<p>
Clients contact shim and open a websocket connection at the /telemetry
service as shown in the example below. When the websocket connection is
first established, shim aggregates all the entries in the telemetry data buffer,
separating them with the newline character (ASCII/UTF8 code 10), and
the message is sent to the client over the websocket.
</p>
<p>
As new data become available, shim aggregates just the new data--again
separating each entry with a newline character--and sends just the new
data to the client over the websocket.
</p>
<p>
Although shim maintains a limited circular buffer of telemetry data, the
clients are free to retain as much data as they like. The example
below illustrates the websockets portion of a Javascript client.
</p>
<pre>
// Global array of raw telemetry data.
telemetry = [];

window.onload = function()
{
  var url = 'ws://' + window.location.host + '/telemetry';
  websocket = new WebSocket(url);
  websocket.onmessage = function(ev)
  {
    telemetry = telemetry.concat(ev.data);
  }
}
</pre>
<p>
In practice, the onmessage function will parse, process and display
the incoming data, and likely limit the size of the array.
</p>



    <footer>
      <br/><br/><p>&copy; Paradigm4 2013</p>
    </footer>

  </div> <!-- /container -->

  <script src="js/jquery.min.js"></script>
  <script src="js/bootstrap.js"></script>

</body>
</html>
